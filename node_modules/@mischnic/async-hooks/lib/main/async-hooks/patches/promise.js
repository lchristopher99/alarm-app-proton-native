"use strict";
exports.__esModule = true;
var PromiseWrap = (function () {
    function PromiseWrap() {
    }
    return PromiseWrap;
}());
function patchPromise(hooks, state) {
    var Promise = global.Promise;
    var oldThen = Promise.prototype.then;
    Promise.prototype.then = wrappedThen;
    function makeWrappedHandler(fn, asyncId, isOnFulfilled) {
        if ('function' !== typeof fn) {
            return isOnFulfilled
                ? makeUnhandledResolutionHandler(asyncId)
                : makeUnhandledRejectionHandler(asyncId);
        }
        return function wrappedHandler() {
            hooks.pre(asyncId);
            try {
                return fn.apply(this, arguments);
            }
            finally {
                hooks.post(asyncId, false);
                hooks.destroy(asyncId);
            }
        };
    }
    function makeUnhandledResolutionHandler(asyncId) {
        return function unhandledResolutionHandler(val) {
            hooks.destroy(asyncId);
            return val;
        };
    }
    function makeUnhandledRejectionHandler(asyncId) {
        return function unhandledRejectedHandler(val) {
            hooks.destroy(asyncId);
            throw val;
        };
    }
    function wrappedThen(onFulfilled, onRejected) {
        if (!state.enabled) {
            return oldThen.call(this, onFulfilled, onRejected);
        }
        var handle = new PromiseWrap();
        var asyncId = state.getNextId();
        hooks.init(asyncId, 0, state.currentId, handle);
        return oldThen.call(this, makeWrappedHandler(onFulfilled, asyncId, true), makeWrappedHandler(onRejected, asyncId, false));
    }
}
exports.patchPromise = patchPromise;
//# sourceMappingURL=promise.js.map