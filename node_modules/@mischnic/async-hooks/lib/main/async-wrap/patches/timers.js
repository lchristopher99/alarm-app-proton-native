"use strict";
exports.__esModule = true;
var timers = require("timers");
function TimeoutWrap() { }
function IntervalWrap() { }
function ImmediateWrap() { }
var timeoutMap = new Map();
var intervalMap = new Map();
var ImmediateMap = new Map();
var activeCallback = null;
var clearedInCallback = false;
function patchTimers(hooks, state) {
    patchTimer(hooks, state, 'setTimeout', 'clearTimeout', TimeoutWrap, timeoutMap, true);
    patchTimer(hooks, state, 'setInterval', 'clearInterval', IntervalWrap, intervalMap, false);
    patchTimer(hooks, state, 'setImmediate', 'clearImmediate', ImmediateWrap, ImmediateMap, true);
    global.setTimeout = timers.setTimeout;
    global.setInterval = timers.setInterval;
    global.setImmediate = timers.setImmediate;
    global.clearTimeout = timers.clearTimeout;
    global.clearInterval = timers.clearInterval;
    global.clearImmediate = timers.clearImmediate;
}
exports.patchTimers = patchTimers;
function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
    var oldSetFn = timers[setFn];
    var oldClearFn = timers[clearFn];
    timers[setFn] = function () {
        if (!state.enabled) {
            return oldSetFn.apply(timers, arguments);
        }
        var args = Array.from(arguments);
        var callback = args[0];
        if (typeof callback !== 'function') {
            throw new TypeError('"callback" argument must be a function');
        }
        var handle = new Handle();
        var asyncId = state.getNextId();
        var timerId;
        hooks.init(asyncId, 0, state.currentId, handle);
        args[0] = function () {
            activeCallback = timerId;
            hooks.pre(asyncId);
            var didThrow = true;
            try {
                callback.apply(this, arguments);
                didThrow = false;
            }
            finally {
                if (didThrow && process.listenerCount('uncaughtException') > 0) {
                    process.once('uncaughtException', function () {
                        hooks.post(asyncId, true);
                        timerMap["delete"](timerId);
                        hooks.destroy(asyncId);
                    });
                }
            }
            hooks.post(asyncId, false);
            activeCallback = null;
            if (singleCall || clearedInCallback) {
                clearedInCallback = false;
                timerMap["delete"](timerId);
                hooks.destroy(asyncId);
            }
        };
        timerId = oldSetFn.apply(void 0, args);
        timerMap.set(timerId, asyncId);
        return timerId;
    };
    timers[clearFn] = function (timerId) {
        if (activeCallback === timerId && timerId !== null) {
            clearedInCallback = true;
        }
        else if (timerMap.has(timerId)) {
            var asyncId = timerMap.get(timerId);
            timerMap["delete"](timerId);
            hooks.destroy(asyncId);
        }
        oldClearFn(timerId);
    };
}
//# sourceMappingURL=timers.js.map